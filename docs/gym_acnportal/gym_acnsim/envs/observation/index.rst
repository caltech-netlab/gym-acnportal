:mod:`gym_acnportal.gym_acnsim.envs.observation`
================================================

.. py:module:: gym_acnportal.gym_acnsim.envs.observation

.. autoapi-nested-parse::

   Module containing definition of a gym_acnsim observation and factory
   functions for different builtin observations.

   See the SimObservation docstring for more information on the
   SimObservation class.

   Each factory function takes no arguments and returns an instance of type
   SimObservation. Each factory function defines a space_function and and
   an obs_function with the following signatures:

   space_function: Callable[[GymInterface], spaces.Space]
   obs_function: Callable[[GymInterface], np.ndarray]

   The space_function gives a gym space for a given observation type.
   The obs_function gives a gym observation for a given observation type.
   The observation returned by obs_function is a point in the space
   returned by space_function.



Module Contents
---------------


.. py:class:: SimObservation(space_function: Callable[[GymTrainedInterface], spaces.Space], obs_function: Callable[[GymTrainedInterface], np.ndarray], name: str)

   Class representing an OpenAI Gym observation of an ACN-Sim
   simulation.

   An instance of SimObservation contains a space_function, which
   generates a gym space from an input Interface using attributes and
   functions of the input Interface, and an obs_function, which
   generates a gym observation from an input Interface using attributes
   and functions of the input Interface. Each instance also requires a
   name (given as a string).

   This class enables Simulation environments with customizable
   observations, as a SimObservation object with user-defined or built
   in space and obs functions can be input to a BaseSimEnv-like object
   to enable a new observation without creating a new environment.

   Each type of observation is the same type of object, but the details
   of the space and obs functions are different. This was done because
   space and obs functions are static, as observations of a specific
   type do not have any attributes. However, each observation type
   requires both a space and observation generating function, so a
   wrapping data structure is required.

   Attributes:
       _space_function (Callable[[GymInterface], spaces.Space]):
           Function that accepts a GymInterface and generates a gym
           space in which all observations for this instance exist.
       _obs_function (Callable[[GymInterface], np.ndarray]): Function
           that accepts a GymInterface and generates a gym observation
           based on the input interface.
       name (str): Name of this observation. This attribute allows an
           environment to distinguish between different types of
           observation.

   .. attribute:: _space_function
      :annotation: :Callable[[GymTrainedInterface], spaces.Space]

      

   .. attribute:: _obs_function
      :annotation: :Callable[[GymTrainedInterface], np.ndarray]

      

   .. attribute:: name
      :annotation: :str

      

   .. method:: get_space(self, interface: GymTrainedInterface)


      Returns the gym space in which all observations for this
      observation type exist. The characteristics of the interface
      (for example, number of EVSEs if station demands are observed)
      may change the dimensions of the returned space, so this method
      requires a GymInterface as input.

      Args:
          interface (GymTrainedInterface): Interface to an ACN-Sim Simulation
              that contains details of and functions to generate
              details about the current Simulation.

      Returns:
          spaces.Space: A gym space in which all observations for this
              observation type exist.


   .. method:: get_obs(self, interface: GymTrainedInterface)


      Returns a gym observation for the state of the simulation given
      by interface. The exact observation depends on both the input
      interface and the observation generating function obs_func with
      which this object was initialized.

      Args:
          interface (GymTrainedInterface): Interface to an ACN-Sim Simulation
              that contains details of and functions to generate
              details about the current Simulation.

      Returns:
          np.ndarray: A gym observation generated by _obs_function
              with this interface.



.. function:: _ev_observation(attribute_function: Callable[[GymTrainedInterface, EV], float], name: str) -> SimObservation


.. function:: arrival_observation() -> SimObservation

   Generates a SimObservation instance that wraps functions to
   observe active EV arrivals.

   Zeros in the output observation array indicate no EV is plugged in;
   as such, all observations are shifted up by 1.


.. function:: departure_observation() -> SimObservation

   Generates a SimObservation instance that wraps functions to
   observe active EV departures.

   Zeros in the output observation array indicate no EV is plugged in;
   as such, all observations are shifted up by 1.


.. function:: remaining_demand_observation() -> SimObservation

   Generates a SimObservation instance that wraps functions to
   observe active EV remaining energy demands in amp periods.

   Zeros in the output observation array indicate no EV is plugged in;
   as such, all observations are shifted up by 1.


.. function:: _constraints_observation(attribute: str, name: str) -> SimObservation


.. function:: constraint_matrix_observation() -> SimObservation

   Generates a SimObservation instance that wraps functions to
   observe the network constraint matrix.


.. function:: magnitudes_observation() -> SimObservation

   Generates a SimObservation instance that wraps functions to
   observe the network limiting current magnitudes in amps.


.. function:: timestep_observation() -> SimObservation

   Generates a SimObservation instance that wraps functions to
   observe the current timestep of the simulation, in periods.

   To comply with the timesteps returned by arrival and departure
   observations, the observed timestep is one greater than than that
   returned by the simulation. Simulations thus start at timestep 1
   from an RL agent's perspective.


